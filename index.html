<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="Bruno Dutra">
    <meta name="generator" content="Doxygen 1.8.11"/>
    <!--<link rel="icon" href="icons/..."> -->
    <title>Metal</title>
    <link href="octicons.css" rel="stylesheet">
    <link href="bootstrap.min.css" rel="stylesheet">
    <link href="metal.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <script>document.body.style.display = "none";</script>
    <nav class="navbar navbar-default navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand" href="#">
            Metal <small>0.2.0</small>
          </a>
        </div>
        <ul class="nav navbar-nav navbar-right">
          <li>
            <a id="download" aria-label="Download from GitHub" href="https://github.com/brunocodutra/metal/archive/v0.2.0.zip">
              <span class="hidden-xs">Download</span>
              <span class="hidden-xs octicon octicon-cloud-download" aria-hidden="true"></span>
              <span class="visible-xs-block mega-octicon octicon-cloud-download" aria-hidden="true"></span>
            </a>
          </li>
          <li>
            <a aria-label="View on GitHub" href="https://github.com/brunocodutra/metal">
              <span class="hidden-xs">View on GitHub</span>
              <span class="hidden-xs octicon octicon-mark-github" aria-hidden="true"></span>
              <span class="visible-xs-block mega-octicon octicon-mark-github" aria-hidden="true"></span>
            </a>
          </li>
        </ul>
      </div>
    </nav>
    <div id="content">
      <div class="container">
        <div class="row">
          <div id="toolbar">
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Documentation</span></a></li>
      <li><a href="modules.html"><span>Reference</span></a></li>
      <li><a href="files.html"><span>Headers</span></a></li>
      <li><a href="namespacemembers.html"><span>Alphabetical&#160;Index</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Documentation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#motivation">Motivation </a></li>
<li class="level1"><a href="#getting_started">Getting Started </a><ul><li class="level2"><a href="#downloading">Downloading </a></li>
<li class="level2"><a href="#installing">Installing </a></li>
<li class="level2"><a href="#using_metal">Using Metal </a></li>
<li class="level2"><a href="#documentation">Documentation </a></li>
<li class="level2"><a href="#header_organization">Header Organization </a></li>
</ul>
</li>
<li class="level1"><a href="#portability">Portability </a><ul><li class="level2"><a href="#status">Current Status </a></li>
</ul>
</li>
<li class="level1"><a href="#concepts">Concepts </a><ul><li class="level2"><a href="#value">Value </a></li>
<li class="level2"><a href="#number">Number </a></li>
<li class="level2"><a href="#optional">Optional </a></li>
<li class="level2"><a href="#expression">Expression </a></li>
<li class="level2"><a href="#lambda">Lambda </a></li>
<li class="level2"><a href="#list">List </a></li>
<li class="level2"><a href="#pair">Pair </a></li>
<li class="level2"><a href="#map">Map </a></li>
</ul>
</li>
<li class="level1"><a href="#homoiconicity">Data-Code Duality </a></li>
<li class="level1"><a href="#metal_in_action">Metal in Action </a><ul><li class="level2"><a href="#parsing_raw_literals">Parsing Raw Literals </a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>Metal is a <a href="#portability">portable</a> header-only <a href="http://en.wikipedia.org/wiki/C%2B%2B14">C++14</a> library designed to make <a href="http://en.wikipedia.org/wiki/Template_metaprogramming">template metaprogramming</a> enjoyable. To that end, it provides a powerful high-level <a href="#concepts">abstraction</a> for compile-time algorithms that mimic the <a href="http://en.cppreference.com/w/cpp/algorithm">standard algorithms library</a>, hence <b>Metal</b> - <b>Meta</b>programming <b>Al</b>gorithms.</p>
<h1><a class="anchor" id="motivation"></a>
Motivation </h1>
<p>Metaprogramming is far from a novelty in the C family, in fact it has been part of everyday C programming since the early days through the <a href="http://en.wikipedia.org/wiki/C_preprocessor">preprocessor</a>. In C++, it was taken to a whole new level with the development of <a href="http://en.wikipedia.org/wiki/Template_metaprogramming">template metaprogramming</a>, a technique that exploits the template system to perform computations during compilation time. Contrary to the C preprocessor, it has long been noticed that <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.3670">C++ templates are indeed Turing complete</a>, thus consolidating template metaprogramming as the standard idiom for compile time computations in C++.</p>
<p>In March of 2003 the <a href="http://boost.org/doc/libs/1_60_0/libs/mpl/doc">Boost Metaprogramming Library</a>, by Aleksey Gurtovoy and David Abrahams, is officially shipped with Boost version 1.30.0. A masterpiece of template metaprogramming, it went to great lengths to support the widest variety of poorly conforming compilers, abstracting away the nastiest compiler hackery to present a uniform framework that finally could be relied upon, thus playing a crucial role in the dissemination of metaprogramming in C++. The Boost.MPL remained undisputed for almost a decade, but eventually, it started showing its age when <a href="http://en.wikipedia.org/wiki/C%2B%2B11">C++11</a> introduced, among various others, <a href="http://en.cppreference.com/w/cpp/language/parameter_pack">variadic templates</a>, <a href="http://en.cppreference.com/w/cpp/language/type_alias">alias templates</a>, <a href="http://en.cppreference.com/w/cpp/language/decltype">type inference</a> and <a href="http://en.cppreference.com/w/cpp/language/constexpr">constant expressions</a> to the core language. The powerful C++11 machinery enabled the development of whole new metaprogramming <a href="http://pdimov.com/cpp2/simple_cxx11_metaprogramming.html">styles</a> and <a href="http://pdimov.com/cpp2/simple_cxx11_metaprogramming_2.html">techniques</a> with potential to outperform Boost.MPL by orders of magnitude in many instances. Moreover, the need for endless automatically generated boilerplate code could finally be overcome using variadic templates, whereas syntax clutter could be mitigated using alias templates, vastly improving readability.</p>
<p>Eventually, <a href="http://rrsd.com/blincubator.com/bi_suggestion/mpl-lite-or-mpl2/">motivation</a> to modernize Boost.MPL emerged from the Boost community, even though opinions diverged widely on the matter. As diverse has been the development of new metaprogramming libraries with varying degrees of success, most notably <a href="http://github.com/ericniebler/meta">meta</a> by Eric Niebler, <a href="http://github.com/Manu343726/Turbo">turbo</a> by Manu SÃ¡nchez and <a href="http://boostorg.github.io/hana">Boost.Hana</a> by Louis Dionne, the latter formally accepted into the Boost distribution in July 2015.</p>
<p>Metal is yet another approach to modern metaprogramming. Its ultimate goal is to be regarded as the natural successor of Boost.MPL in every use case where C++14 is available, delivering greater performance and expressiveness without cluttering the codebase. Although not a perfect drop in replacement for Boost.MPL, Metal follows very similar design principles, except that they have been fine tuned to take advantage of C++14, so migration is meant to be the smoothest possible.</p>
<h1><a class="anchor" id="getting_started"></a>
Getting Started </h1>
<p>It's very easy to start enjoying metaprogramming with Metal, being header-only with no external dependencies, all you have to do is download it.</p>
<h2><a class="anchor" id="downloading"></a>
Downloading </h2>
<p>There are a few ways to get a copy of Metal, the easiest might be to simply <a href="" class="download">download the latest release</a> as a compressed package.</p>
<p>If you have git installed and would rather have the latest stable Metal, you may consider cloning branch <code>master</code> from GitHub. </p><pre class="fragment">git clone https://github.com/brunocodutra/metal
</pre><p>Likewise, the bleeding edge development version can be obtained by cloning branch <code>develop</code> instead. </p><pre class="fragment">git clone https://github.com/brunocodutra/metal --branch=develop
</pre><div class="panel panel-warning"><div class="panel-heading"><span class="octicon octicon-info"></span>Note</div><div class="panel-body"> During development it is possible that branch <code>develop</code> breaks temporarily. Be sure to check current compilation <a href="#status">status</a> prior to cloning. </div></div><h2><a class="anchor" id="installing"></a>
Installing </h2>
<p>Metal may optionally be installed system-wide to ease integration with external projects. It relies on <a href="http://cmake.org/">CMake</a> v2.8 or newer to automate the installation process, so you need to have it installed on your system before proceeding.</p>
<p>From within an empty directory issue the following commands. </p><pre class="fragment">cmake /path/to/Metal
cmake --build . --target install
</pre><p>Unless otherwise specified, Metal's include tree will be copied into the default prefix for locally installed libraries in your platform, that is <code>/usr/local/include</code> on Unix[-like] systems and <code>C:\Program Files\Metal\include</code> on Windows. Simply add the installation prefix to the include search path of your compiler/project if it isn't by default, and you're good to go.</p>
<h2><a class="anchor" id="using_metal"></a>
Using Metal </h2>
<p>Metal may be used as is immediately after downloading, simply add its <code>include/</code> sub-directory to the include search paths of your compiler/project and you're all set.</p>
<p>If your project uses <a href="http://cmake.org/">CMake</a>, Metal may easily be integrated into your project via <code>find_package</code>, whereupon <code>METAL_INCLUDE_DIRS</code> is set to contain all necessary include prefixes. If you have installed Metal system-wide, it should suffice to add the following to the <code>CMakeLists.txt</code> of your project. </p><pre class="fragment">find_package(Metal REQUIRED)
include_directories(${METAL_INCLUDE_DIRS})
</pre><div class="panel panel-warning"><div class="panel-heading"><span class="octicon octicon-info"></span>Note</div><div class="panel-body">Please remember to enable at least C++14 support in order to use Metal.</div></div><div class="panel panel-info"><div class="panel-heading"><span class="octicon octicon-light-bulb"></span>Tip</div><div class="panel-body"> If your project is using CMake 3.1 or newer, <a href="https://cmake.org/cmake/help/v3.1/variable/CMAKE_CXX_STANDARD.html"><code>CMAKE_CXX_STANDARD</code></a> may be used to globally enable specific C++ standards. Simply set it to <code>14</code> or later before adding any target that depends on Metal. </div></div><p>For more information, please refer to the <a href="http://cmake.org/documentation/">CMake documentation</a>.</p>
<h2><a class="anchor" id="documentation"></a>
Documentation </h2>
<p>An offline copy of this very documentation may be obtained by cloning branch <code>gh-pages</code>. </p><pre class="fragment">git clone https://github.com/brunocodutra/metal --branch=gh-pages
</pre><p>Alternatively, if you have <a href="http://cmake.org/">CMake</a> and <a href="http://doxygen.org/">Doxygen</a> installed, the documentation may also be built locally. From within an empty directory issue the following commands. </p><pre class="fragment">cmake /path/to/Metal
cmake --build . --target doc
</pre><p>The documentation will be generated into <code>doc/html/</code>.</p>
<p>To browse the documentation offline, simply load <code>index.html</code> on any web browser that supports <a href="http://en.wikipedia.org/wiki/JavaScript">JavaScript</a>.</p>
<h2><a class="anchor" id="header_organization"></a>
Header Organization </h2>
<p>Each header in Metal is named after the construct it defines, so for instance <a class="el" href="distinct_8hpp_source.html">distinct.hpp</a> defines <a class="el" href="group__list.html#gaf1d3cd5610c963df4432345fe5e14e82">metal::distinct</a>, while <a class="el" href="invoke_8hpp_source.html">invoke.hpp</a> defines <a class="el" href="group__lambda.html#ga033d8237ad8c9905332a2f9907e383ec">metal::invoke</a> and so on.</p>
<p>Headers are semantically organized within modules, which are named after each <a href="#concepts">concept</a>. Each module corresponds to a directory in the filesystem and may naturally contain sub-modules, that is, sub-directories. Along each directory, on the same level in the filesystem, there is a also header file with the same name of that directory that includes every header therein.</p>
<p>The complete hierarchy of modules and headers that comprise Metal is available in section <a href="files.html">Headers</a>.</p>
<p>Finaly, headers within <code>detail/</code> are undocumented and should be expected to undergo breaking changes without prior notice, so directly depending on these headers or,likewise, anything within <code>namespace metal::detail</code>, is strongly discouraged.</p>
<h1><a class="anchor" id="portability"></a>
Portability </h1>
<p>Great effort is undertaken to keep Metal strictly in conformance with the C++14 standard and compatible with the widest possible variety of compilers. To this end, some of the most popular freely available C++ compilers are actively supported through <a href="http://en.wikipedia.org/wiki/Continuous_integration">Continuous Integration (CI)</a> premisses. GCC and Clang are tested with help of <a href="http://travis-ci.org/brunocodutra/metal">Travis CI</a>, while Microsoft Visual Studio is tested using <a href="http://ci.appveyor.com/project/brunocodutra/metal">Appveyor CI</a>.</p>
<h2><a class="anchor" id="status"></a>
Current Status </h2>
<p>Current compilation status is summarized in the table bellow, if your favorite compiler is not included, please <a href="http://github.com/brunocodutra/metal/issues">let us know</a>.</p>
<table class="doxtable">
<tr>
<th rowspan="2">Compiler </th><th rowspan="2" class="hidden-xs">Minimum Version </th><th colspan="2">Branch  </th></tr>
<tr>
<th>Master </th><th><p class="starttd">Develop </p>
<p class="endtd"></p>
</th></tr>
<tr>
<th>GCC </th><td class="hidden-xs">4.9 </td><td rowspan="2"><div class="image">
<img src="http://travis-ci.org/brunocodutra/metal.svg?branch=master"  alt="travis.master"/>
</div>
 </td><td rowspan="2"><div class="image">
<img src="http://travis-ci.org/brunocodutra/metal.svg?branch=develop"  alt="travis.develop"/>
</div>
  </td></tr>
<tr>
<th>Clang </th><td class="hidden-xs">3.5  </td></tr>
<tr>
<th>MSVC </th><td class="hidden-xs">14 (2015) </td><td><div class="image">
<img src="http://ci.appveyor.com/api/projects/status/85pk8n05n4r5x103/branch/master?svg=true"  alt="appveyor.master"/>
</div>
 </td><td><div class="image">
<img src="http://ci.appveyor.com/api/projects/status/85pk8n05n4r5x103/branch/develop?svg=true"  alt="appveyor.develop"/>
</div>
  </td></tr>
</table>
<div class="panel panel-warning"><div class="panel-heading"><span class="octicon octicon-info"></span>Note</div><div class="panel-body"> Status badges are updated live to reflect current status as reported by the continuous integration tools. If they don't load correctly that might be due to a temporary network downtime. </div></div><h1><a class="anchor" id="concepts"></a>
Concepts </h1>
<p>Template metaprogramming can be seen as a language of its own right, sharing the same syntax with C++, but having different semantics. Because constructs assume different meanings during template metaprogramming from what they usually mean in an actual C++ context, some key concepts must be defined.</p>
<h2><a class="anchor" id="value"></a>
Value </h2>
<p><a href="#value">Values</a> are the objects of metaprogramming.</p>
<h3>Requirements</h3>
<p>Any type is a <a href="#value">Value</a>.</p>
<h3>Examples</h3>
<div class="fragment"><div class="line"><span class="keyword">using</span> val = int;</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">using</span> val = decltype(3.14);</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">struct </span>val</div><div class="line">{</div><div class="line">    <span class="comment">//...</span></div><div class="line">};</div></div><!-- fragment --> <h3>Counterexamples</h3>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> not_a_value;</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">auto</span> not_a_value = 3.14;</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">struct</span></div><div class="line">{</div><div class="line">    <span class="comment">//...</span></div><div class="line">} not_a_value;</div></div><!-- fragment --> <h2><a class="anchor" id="number"></a>
Number </h2>
<p>A <a href="#number">Number</a> is a compile-time representation of a numerical value.</p>
<h3>Requirements</h3>
<p><code>num</code> is a model of <a href="#number">Number</a> if and only if <code>num</code> is an alias to a specialization of <a href="http://en.cppreference.com/w/cpp/types/integral_constant">std::integral_constant</a>.</p>
<h3>Examples</h3>
<div class="fragment"><div class="line"><span class="keyword">using</span> num = std::false_type;</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">using</span> num = std::integral_constant&lt;int, -1&gt;;</div></div><!-- fragment --> <h3>Counterexamples</h3>
<div class="fragment"><div class="line"><span class="keyword">struct </span>not_a_number :</div><div class="line">    std::true_type</div><div class="line">{};</div></div><!-- fragment --> <h3>See Also</h3>
<p><a class="el" href="group__number.html#ga1e4f1eb3349be74f99e7c70e4af8be9e">metal::number</a>, <a class="el" href="group__number.html#ga7b9dc87eada8b3d86cbfa6cae1383d90">metal::boolean</a>, <a class="el" href="group__number.html#ga1a740d0ee36cdefe127eaabfe85cb770">metal::integer</a>, <a class="el" href="group__number.html#gabbc51719da6b0cfb01a5d8617ebee59e">metal::character</a></p>
<h2><a class="anchor" id="optional"></a>
Optional </h2>
<p><a href="#optional">Optionals</a> are <a href="#value">Values</a> that represent either <em>just</em> some other <a href="#value">Value</a> or <em>nothing</em>.</p>
<p>In order to <em>evaluate</em> an <a href="#optional">Optional</a> one must explicitly name its nested <code>::type</code>. An <a href="#optional">Optional</a> is said to be empty, whenever a nested <a href="#value">Value</a> called <code>::type</code> is undefined or ambiguously defined, thus attempting to <em>evaluate</em> an empty <a href="#optional">Optional</a> leads to a compile-time error.</p>
<div class="panel panel-info"><div class="panel-heading"><span class="octicon octicon-light-bulb"></span>Tip</div><div class="panel-body"> <code><a class="el" href="group__optional.html#gab9f0eb6e48966564181d51b53083a119">metal::eval</a>&lt;opt&gt;</code> is equivalent to <code>typename opt::type</code> for any <a href="#optional">Optional</a> <code>opt</code>. </div></div><h3>Requirements</h3>
<p>Any <a href="#value">Value</a> is also an <a href="#optional">Optional</a>.</p>
<h3>Examples</h3>
<div class="fragment"><div class="line"><span class="keyword">struct </span>opt</div><div class="line">{</div><div class="line">    <span class="keyword">struct </span>type; <span class="comment">//just some value</span></div><div class="line">};</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">using</span> opt = void; <span class="comment">//nothing - undefined ::type</span></div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">struct </span>opt</div><div class="line">{</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span>...&gt;</div><div class="line">    <span class="keyword">struct </span>type; <span class="comment">//nothing - ::type is not a model of Value</span></div><div class="line">};</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">struct </span>optional1</div><div class="line">{</div><div class="line">    <span class="keyword">struct </span>type; <span class="comment">//just some value</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct </span>optional2</div><div class="line">{</div><div class="line">    <span class="keyword">struct </span>type; <span class="comment">//just some other value</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct </span>optional3 :</div><div class="line">    optional1,</div><div class="line">    optional2</div><div class="line">{</div><div class="line">    <span class="comment">//nothing - ambiguous ::type</span></div><div class="line">};</div></div><!-- fragment --> <h3>See Also</h3>
<p><a class="el" href="group__optional.html#ga196430b4e0444ea019c8178ce0d29f4a">metal::optional</a>, <a class="el" href="group__optional.html#ga5eab6218db35d3c18aa1e729ef084653">metal::just</a>, <a class="el" href="group__optional.html#gaf1df53777ce2fa6ecd7505f13652aaf7">metal::nothing</a>, <a class="el" href="group__optional.html#gab9f0eb6e48966564181d51b53083a119">metal::eval</a></p>
<h2><a class="anchor" id="expression"></a>
Expression </h2>
<p><a href="#expression">Expressions</a>, also called <em>metafunctions</em>, are functions that operate on <a href="#value">Values</a>.</p>
<p>Unlike run-time functions, <a href="#expression">Expressions</a> are lazy, that is, an <a href="#expression">Expression</a> bound to some set of arguments is itself a model of <a href="#optional">Optional</a>, that means one must explicitly name its nested <code>::type</code> in order to actually <em>evaluate</em> an <a href="#expression">Expression</a>. In general, however, an <a href="#expression">Expression</a> may be <em>empty</em> for some set of arguments, thus attempting to <em>evaluate</em> such an <a href="#expression">Expression</a> for such set of arguments leads to a compile-time error.</p>
<div class="panel panel-info"><div class="panel-heading"><span class="octicon octicon-light-bulb"></span>Tip</div><div class="panel-body"> To save typing, most <a href="#expression">Expressions</a> in Metal have an associated eager adaptor suffixed by <code>_t</code>, that is, given an expression <code>metal::expr</code>, <code>metal::expr_t&lt;...&gt;</code> is equivalent to <code>typename metal::expr&lt;...&gt;::type</code>. </div></div><h3>Requirements</h3>
<p><code>expr</code> is a model of <a href="#expression">Expression</a> if and only if <code>expr</code> is a template class, union or alias that only expects types as arguments.</p>
<h3>Examples</h3>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt;</div><div class="line"><span class="keyword">union </span>expr</div><div class="line">{</div><div class="line">    <span class="keyword">struct </span>type; <span class="comment">//evaluable for every argument</span></div><div class="line">};</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...&gt;</div><div class="line"><span class="keyword">struct </span>expr</div><div class="line">{</div><div class="line">    <span class="comment">//not evaluable for any set of arguments</span></div><div class="line">};</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> array&gt; <span class="comment">//evaluable for array types</span></div><div class="line"><span class="keyword">using</span> expr = std::enable_if&lt;!!std::rank&lt;array&gt;::value, array&gt;;</div></div><!-- fragment --> <h3>Counterexamples</h3>
<div class="fragment"><div class="line"><span class="keyword">struct </span>not_an_expression <span class="comment">//not a template</span></div><div class="line">{</div><div class="line">    <span class="keyword">struct </span>type;</div><div class="line">};</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;<span class="keyword">typename</span>...&gt; <span class="keyword">class</span>... exprs&gt; <span class="comment">//non-type parameter</span></div><div class="line"><span class="keyword">struct </span>not_an_expression</div><div class="line">{</div><div class="line">    <span class="keyword">struct </span>type;</div><div class="line">};</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="keywordtype">int</span>egral, <span class="keywordtype">int</span>egral <span class="keywordtype">int</span>egral_value&gt; <span class="comment">//non-type parameter</span></div><div class="line"><span class="keyword">using</span> not_an_expression = std::integral_constant&lt;integral, integral_value&gt;;</div></div><!-- fragment --><h2><a class="anchor" id="lambda"></a>
Lambda </h2>
<p><a href="#lambda">Lambdas</a>, short for <em>Lambda Expressions</em>, are <a href="http://en.wikipedia.org/wiki/First-class_citizen">first-class expressions</a> that operate on <a href="#value">Values</a>. As <a href="#value">Values</a> themselves, <a href="#lambda">Lambdas</a> can serve both as argument as well as return type to other <a href="#lambda">Lambdas</a>, thus enabling <a href="http://en.wikipedia.org/wiki/Higher-order_function">higher-order</a> metaprogramming.</p>
<p><a href="#lambda">Lambdas</a> are named after formal system for computability, the <a href="http://en.wikipedia.org/wiki/Lambda_calculus">Lambda Calculus</a>.</p>
<h3>Requirements</h3>
<p>Any <a href="#value">Value</a> is also a <a href="#lambda">Lambda</a>.</p>
<h3>Semantics</h3>
<p>Let <code>expr</code> be an <a href="#expression">Expression</a>, <code>[a1, ..., ai, ..., an]</code> atomic <a href="#value">Values</a>, <code>[_1, ..., _i, ..., _n]</code> <a class="el" href="group__placeholders.html">Placeholders</a> and <code>[l1, ..., li, ..., ln]</code> <a href="#lambda">Lambdas</a>.</p>
<ul>
<li>Invoking <code>ai</code> with any (possibly empty) set of <a href="#value">Values</a> yields <code>ai</code></li>
<li>Invoking <code>_i</code> with <code>[a1, ..., ai, ..., an]</code> yields <code>ai</code></li>
<li>Invoking <code><a class="el" href="group__lambda.html#gad1c1dcdd5fae23712d016b52504cbb22">metal::lambda</a>&lt;expr&gt;</code> with <code>[a1, ..., an]</code> yields <code>expr&lt;a1, ..., an&gt;::type</code></li>
<li>Invoking <code>expr&lt;l1, ..., li, ..., ln&gt;</code> with <code>[a1, ..., an]</code> invokes <code><a class="el" href="group__lambda.html#gad1c1dcdd5fae23712d016b52504cbb22">metal::lambda</a>&lt;expr&gt;</code> with the <a href="#value">Values</a> yielded by recursively invoking each <code>li</code> with <code>[a1, ..., an]</code>.</li>
</ul>
<div class="panel panel-info"><div class="panel-heading"><span class="octicon octicon-light-bulb"></span>Tip</div><div class="panel-body"> <code><a class="el" href="group__lambda.html#gad1c1dcdd5fae23712d016b52504cbb22">metal::lambda</a>&lt;expr&gt;</code> can be used to adapt any <a href="#expression">Expression</a> <code>expr</code> into a <a href="#lambda">Lambda</a>. </div></div><h3>Examples</h3>
<div class="fragment"><div class="line"><span class="keyword">using</span> lbd = void;</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">using</span> lbd = <a class="code" href="group__placeholders.html#ga91c75729b0f78f2b5c069aec6cb07ef4">metal::_2</a>;</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">using</span> lbd = <a class="code" href="group__lambda.html#gad1c1dcdd5fae23712d016b52504cbb22">metal::lambda&lt;std::add_pointer&gt;</a>;</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">using</span> lbd = std::add_pointer&lt;void&gt;;</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">using</span> lbd = std::is_same&lt;<a class="code" href="group__placeholders.html#ga2158e3dd5180b12b04dc1dc487fef023">metal::_1</a>, <a class="code" href="group__lambda.html#gad1c1dcdd5fae23712d016b52504cbb22">metal::lambda</a>&lt;std::common_type&gt;&gt;;</div></div><!-- fragment --> <h3>See Also</h3>
<p><a class="el" href="group__lambda.html#ga033d8237ad8c9905332a2f9907e383ec">metal::invoke</a>, <a class="el" href="group__lambda.html#ga54c2fb7fe55cb0d42929b2806b845e7b">metal::arg</a>, <a class="el" href="group__lambda.html#gad1c1dcdd5fae23712d016b52504cbb22">metal::lambda</a></p>
<h2><a class="anchor" id="list"></a>
List </h2>
<p>A <a href="#list">List</a> is a sequence of <a href="#value">Values</a>.</p>
<h3>Requirements</h3>
<p>A <a href="#list">List</a> is any specialization of any template class or union that only expects types as arguments.</p>
<h3>Examples</h3>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt;</div><div class="line"><span class="keyword">union </span>single;</div><div class="line"></div><div class="line"><span class="keyword">using</span> <a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">list</a> = single&lt;int&gt;;</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...&gt;</div><div class="line"><span class="keyword">class </span>many;</div><div class="line"></div><div class="line"><span class="keyword">using</span> <a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">list</a> = many&lt;&gt;;</div></div><!-- fragment --> <h3>Counterexamples</h3>
<div class="fragment"><div class="line"><span class="keyword">using</span> not_a_list = <span class="keyword">struct</span>{}; <span class="comment">// not a template instantiation</span></div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t, t...&gt;</div><div class="line"><span class="keyword">struct </span>numbers;</div><div class="line"></div><div class="line"><span class="keyword">using</span> not_a_list = numbers&lt;<span class="keywordtype">int</span> <span class="comment">/*, ...*/</span>&gt;; <span class="comment">// non-type arguments</span></div></div><!-- fragment --> <h3>See Also</h3>
<p><a class="el" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list</a>, <a class="el" href="group__list.html#gaa4cdc79ab18355eaaa40caa5819a2f1c">metal::is_list</a></p>
<h2><a class="anchor" id="pair"></a>
Pair </h2>
<p>A <a href="#pair">Pair</a> is a couple of <a href="#value">Values</a>.</p>
<h3>Requirements</h3>
<p>A <a href="#pair">Pair</a> is any <a href="#list">List</a> whose size is 2.</p>
<h3>Examples</h3>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>&gt;</div><div class="line"><span class="keyword">struct </span>couple;</div><div class="line"></div><div class="line"><span class="keyword">using</span> <a class="code" href="group__pair.html#gafe4f3a3f2854c485c9b455c6ea70271d">pair</a> = couple&lt;int, unsigned&gt;;</div></div><!-- fragment --> <h3>Counterexamples</h3>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...&gt;</div><div class="line"><span class="keyword">struct </span>many;</div><div class="line"></div><div class="line"><span class="keyword">using</span> not_a_pair = many&lt;&gt;; <span class="comment">// size != 2</span></div></div><!-- fragment --> <h3>See Also</h3>
<p><a class="el" href="group__pair.html#gafe4f3a3f2854c485c9b455c6ea70271d">metal::pair</a>, <a class="el" href="group__pair.html#ga239933bfe243fa00bfb8a204b7098d89">metal::is_pair</a>, <a class="el" href="group__pair.html#ga5df51526bf8362fb2e4b7ccdc745db08">metal::first</a>, <a class="el" href="group__pair.html#ga271b2edbc78a913d59bb4e5f7a8cc92a">metal::second</a></p>
<h2><a class="anchor" id="map"></a>
Map </h2>
<p>A <a href="#map">Map</a> is a collection of unique <a href="#value">Values</a>, each of which is associated with another <a href="#value">Value</a>.</p>
<h3>Requirements</h3>
<p>A <a href="#map">Map</a> is a <a href="#list">List</a> of <a href="#pair">Pairs</a>, whose first elements are all distinct, that is </p><pre class="fragment">[[k0, v0], ..., [kn, vn]]; ki != kj for all i, j in {0, n} and i != j
</pre><h3>Examples</h3>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...&gt;</div><div class="line"><span class="keyword">struct </span>many;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>&gt;</div><div class="line"><span class="keyword">union </span>couple;</div><div class="line"></div><div class="line"><span class="keyword">using</span> <a class="code" href="group__map.html#gae0cd7c57566eae1abed8c1b32e76f997">map</a> = many&lt;couple&lt;int, int*&gt;, many&lt;void, void*&gt;, couple&lt;float, float*&gt;&gt;;</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...&gt;</div><div class="line"><span class="keyword">struct </span>many;</div><div class="line"></div><div class="line"><span class="keyword">using</span> <a class="code" href="group__map.html#gae0cd7c57566eae1abed8c1b32e76f997">map</a> = many&lt;&gt;;</div></div><!-- fragment --> <h3>Counterexamples</h3>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...&gt;</div><div class="line"><span class="keyword">struct </span>many;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>&gt;</div><div class="line"><span class="keyword">union </span>couple;</div><div class="line"></div><div class="line"><span class="keyword">using</span> not_a_map = many&lt;couple&lt;int, int*&gt;, couple&lt;int, int&amp;&gt;&gt;; <span class="comment">// repeated keys</span></div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...&gt;</div><div class="line"><span class="keyword">struct </span>many;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt;</div><div class="line"><span class="keyword">class </span>single;</div><div class="line"></div><div class="line"><span class="keyword">using</span> not_a_map = many&lt;single&lt;void&gt;, many&lt;int, int&gt;&gt;; <span class="comment">// not a list of pairs</span></div></div><!-- fragment --> <h3>See Also</h3>
<p><a class="el" href="group__map.html#gae0cd7c57566eae1abed8c1b32e76f997">metal::map</a>, <a class="el" href="group__map.html#ga50985f3fbea722280dabf10d1f0827c9">metal::is_map</a>, <a class="el" href="group__map.html#ga93e0861037f4a2d14392eb88f3f41987">metal::keys</a>, <a class="el" href="group__map.html#gaa577d7b50596764830c0404aabd681b9">metal::values</a></p>
<h1><a class="anchor" id="homoiconicity"></a>
Data-Code Duality </h1>
<p>Markedly influenced by various functional programming languages, such as <a href="http://en.wikipedia.org/wiki/Haskell_%28programming_language%29">Haskell</a> and <a href="http://en.wikipedia.org/wiki/Standard_ML">SML</a>, Metal owes much of its design particularly to <a href="http://en.wikipedia.org/wiki/Lisp_%28programming_language%29">Lisp</a>. From it, Metal borrowed <a href="http://en.wikipedia.org/wiki/S-expression">s-expressions</a> and the notion that data structures and algorithms are nothing but <a href="http://en.wikipedia.org/wiki/Homoiconicity">two sides of the same coin</a>, that is, Metal makes no difference between lists and unevaluated expressions.</p>
<p>Take for instance the following definition.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> sum = <a class="code" href="group__arithmetic.html#ga9b2e18aa329355bfd7da7b374823b421">metal::add</a>&lt;<a class="code" href="group__number.html#ga1a740d0ee36cdefe127eaabfe85cb770">metal::integer&lt;2&gt;</a>, <a class="code" href="group__number.html#ga1a740d0ee36cdefe127eaabfe85cb770">metal::integer&lt;3&gt;</a>, <a class="code" href="group__number.html#ga1a740d0ee36cdefe127eaabfe85cb770">metal::integer&lt;5&gt;</a>&gt;;</div></div><!-- fragment --><p> Here <code>sum</code> could be understood as an unevaluated addition of three numbers, thus</p>
<div class="fragment"><div class="line">static_assert(std::is_same&lt;<a class="code" href="group__optional.html#gab9f0eb6e48966564181d51b53083a119">metal::eval&lt;sum&gt;</a>, <a class="code" href="group__number.html#ga1a740d0ee36cdefe127eaabfe85cb770">metal::integer&lt;10&gt;</a>&gt;::value, <span class="stringliteral">&quot;&quot;</span>);</div></div><!-- fragment --><p> Alternativelly, <code>sum</code> could also be seen as a <a href="#list">List</a> that contains three values</p>
<div class="fragment"><div class="line">static_assert(<a class="code" href="group__list.html#gaa4cdc79ab18355eaaa40caa5819a2f1c">metal::is_list&lt;sum&gt;::value</a>, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">static_assert(<a class="code" href="group__list.html#ga0a14517a9f48b5b338ac3834fd44bced">metal::size_t&lt;sum&gt;::value</a> == 3, <span class="stringliteral">&quot;&quot;</span>);</div></div><!-- fragment --><p> Now, just like any <a href="#list">List</a>, <code>sum</code> may be transformed into a new <a href="#list">List</a></p>
<div class="fragment"><div class="line"><span class="keyword">using</span> sqsum = <a class="code" href="group__list.html#ga61ea84621d6c85e098c5e182604b58cb">metal::transform_t&lt;metal::pow&lt;metal::_1, metal::integer&lt;2&gt;</a>&gt;, sum&gt;;</div></div><!-- fragment --><p> ... which in turn may be seen as the sum of the squares of the same three numbers.</p>
<div class="fragment"><div class="line">static_assert(std::is_same&lt;<a class="code" href="group__optional.html#gab9f0eb6e48966564181d51b53083a119">metal::eval&lt;sqsum&gt;</a>, <a class="code" href="group__number.html#ga1a740d0ee36cdefe127eaabfe85cb770">metal::integer&lt;38&gt;</a>&gt;::value, <span class="stringliteral">&quot;&quot;</span>);</div></div><!-- fragment --> <h1><a class="anchor" id="metal_in_action"></a>
Metal in Action </h1>
<p>Enough theory, lets see some action!</p>
<h2><a class="anchor" id="parsing_raw_literals"></a>
Parsing Raw Literals </h2>
<p>If you ever considered augmenting <a href="http://en.cppreference.com/w/cpp/utility/tuple"><code>std::tuple</code></a>, so that instead of the rather odd <a href="http://en.cppreference.com/w/cpp/utility/tuple/get"><code>std::get&lt;N&gt;()</code></a></p>
<div class="fragment"><div class="line">static_assert(std::get&lt;1&gt;(std::tuple&lt;int, char, double&gt;{42, <span class="charliteral">&#39;a&#39;</span>, 2.5}) == <span class="charliteral">&#39;a&#39;</span>, <span class="stringliteral">&quot;&quot;</span>);</div></div><!-- fragment --><p> one could just use the more intuitive subscript operator <code>[N]</code>,</p>
<div class="strike"> <div class="fragment"><div class="line">static_assert(SuperTuple&lt;int, char, double&gt;{42, <span class="charliteral">&#39;a&#39;</span>, 2.5}[1] == <span class="charliteral">&#39;a&#39;</span>, <span class="stringliteral">&quot;&quot;</span>);</div></div><!-- fragment --></div><p>chances are you realized the hard way that there is simply no way of overloading such an operator!</p>
<p>All is not lost however if you can live with the subscript operator taking an object of type <code>std::integral_constant</code>, or in Metal's parlance <a href="#number">Number</a>, instead of an usual integral value.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</div><div class="line"><span class="keyword">struct </span>SuperTuple :</div><div class="line">    std::tuple&lt;T...&gt;</div><div class="line">{</div><div class="line">    <span class="keyword">using</span> std::tuple&lt;T...&gt;::tuple;</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> I, I i&gt;</div><div class="line">    constexpr <span class="keyword">auto</span> operator [](<a class="code" href="group__number.html#ga1e4f1eb3349be74f99e7c70e4af8be9e">metal::number&lt;I, i&gt;</a>)</div><div class="line">        -&gt; <span class="keyword">typename</span> std::tuple_element&lt;i, std::tuple&lt;T...&gt;&gt;::type&amp; {</div><div class="line">        <span class="keywordflow">return</span> std::get&lt;i&gt;(*this);</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --> <div class="fragment"><div class="line">static_assert(SuperTuple&lt;int, char, double&gt;{42, <span class="charliteral">&#39;a&#39;</span>, 2.5}[1_c] == <span class="charliteral">&#39;a&#39;</span>, <span class="stringliteral">&quot;&quot;</span>);</div></div><!-- fragment --><p> Neat isn't it? Now we need a <a href="http://en.cppreference.com/w/cpp/language/user_literal">literal operator</a> <code>_c</code> that encodes an integral value as a <a href="#number">Number</a>. Sounds simple enough, right?</p>
<div class="strike"> <div class="fragment"><div class="line">constexpr <span class="keyword">auto</span> <span class="keyword">operator</span> <span class="stringliteral">&quot;&quot;</span>_c(<span class="keywordtype">long</span> <span class="keywordtype">long</span> i)</div><div class="line">    -&gt; std::integral_constant&lt;long long, i&gt; {</div><div class="line">    <span class="keywordflow">return</span> {};</div><div class="line">}</div></div><!-- fragment --></div><p>Not really. While <code>constexpr</code> tells the compiler the value returned by <code>operator ""_c</code> might be a compile time constant, it tells no such thing about its argument. We are thus left no other option but to parse raw literals ourselves, in other words, we are in for some fun!</p>
<h3>The Raw Literal Operator Template</h3>
<p>Raw literal operator templates are defined as a nullary function templated over <code>char...</code>, such as</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">char</span>... tokens&gt;</div><div class="line">constexpr <span class="keyword">auto</span> <span class="keyword">operator</span> <span class="stringliteral">&quot;&quot;</span>_raw()</div><div class="line">    -&gt; <a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list&lt;metal::character&lt;tokens&gt;</a>...&gt; {</div><div class="line">    <span class="keywordflow">return</span> {};</div><div class="line">}</div></div><!-- fragment --><p> where <code>tokens...</code> are mapped to the exact characters that make up the literal, including the prefixes <code>0x</code> and <code>0b</code></p>
<div class="fragment"><div class="line">static_assert(std::is_same&lt;</div><div class="line">    decltype(371_raw),</div><div class="line">    <a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list</a>&lt;</div><div class="line">        <a class="code" href="group__number.html#gabbc51719da6b0cfb01a5d8617ebee59e">metal::character&lt;'3'&gt;</a>,</div><div class="line">        <a class="code" href="group__number.html#gabbc51719da6b0cfb01a5d8617ebee59e">metal::character&lt;'7'&gt;</a>,</div><div class="line">        <a class="code" href="group__number.html#gabbc51719da6b0cfb01a5d8617ebee59e">metal::character&lt;'1'&gt;</a></div><div class="line">    &gt;</div><div class="line">&gt;::value, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line">static_assert(std::is_same&lt;</div><div class="line">    decltype(0x371_raw),</div><div class="line">    <a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list</a>&lt;</div><div class="line">        <a class="code" href="group__number.html#gabbc51719da6b0cfb01a5d8617ebee59e">metal::character&lt;'0'&gt;</a>, <a class="code" href="group__number.html#gabbc51719da6b0cfb01a5d8617ebee59e">metal::character&lt;'x'&gt;</a>,</div><div class="line">        <a class="code" href="group__number.html#gabbc51719da6b0cfb01a5d8617ebee59e">metal::character&lt;'3'&gt;</a>, <a class="code" href="group__number.html#gabbc51719da6b0cfb01a5d8617ebee59e">metal::character&lt;'7'&gt;</a>, <a class="code" href="group__number.html#gabbc51719da6b0cfb01a5d8617ebee59e">metal::character&lt;'1'&gt;</a></div><div class="line">    &gt;</div><div class="line">&gt;::value, <span class="stringliteral">&quot;&quot;</span>);</div></div><!-- fragment --><p> as well as the digit separator <code>'</code> introduced in <a href="http://en.wikipedia.org/wiki/C%2B%2B14">C++14</a></p>
<div class="fragment"><div class="line">static_assert(std::is_same&lt;</div><div class="line">    decltype(3<span class="charliteral">&#39;7&#39;</span>1_raw),</div><div class="line">    <a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list</a>&lt;</div><div class="line">        <a class="code" href="group__number.html#gabbc51719da6b0cfb01a5d8617ebee59e">metal::character&lt;'3'&gt;</a>,</div><div class="line">        <a class="code" href="group__number.html#gabbc51719da6b0cfb01a5d8617ebee59e">metal::character&lt;'\''&gt;</a>,</div><div class="line">        <a class="code" href="group__number.html#gabbc51719da6b0cfb01a5d8617ebee59e">metal::character&lt;'7'&gt;</a>,</div><div class="line">        <a class="code" href="group__number.html#gabbc51719da6b0cfb01a5d8617ebee59e">metal::character&lt;'\''&gt;</a>,</div><div class="line">        <a class="code" href="group__number.html#gabbc51719da6b0cfb01a5d8617ebee59e">metal::character&lt;'1'&gt;</a></div><div class="line">    &gt;</div><div class="line">&gt;::value, <span class="stringliteral">&quot;&quot;</span>);</div></div><!-- fragment --> <h3>The <code>operator ""_c</code></h3>
<p>We start by defining our very own literal operator <code>_c</code>. It simply wraps each token into a <code><a class="el" href="group__number.html#gabbc51719da6b0cfb01a5d8617ebee59e">metal::character</a></code> and forwards them to an <a href="#expression">Expression</a> that effectively parses the <a href="#number">Number</a>, we'll call it, suggestively, <code>make_number</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">char</span>... tokens&gt;</div><div class="line">constexpr <span class="keyword">auto</span> <span class="keyword">operator</span> <span class="stringliteral">&quot;&quot;</span>_c()</div><div class="line">    -&gt; make_number_t&lt;metal::character&lt;tokens&gt;...&gt; {</div><div class="line">    <span class="keywordflow">return</span> {};</div><div class="line">}</div></div><!-- fragment --> <h3>Resolving the Radix</h3>
<p>In its turn <code>make_number</code> strips the prefix, if any, thus resolving the radix, then forwards the remaining tokens to <code>parse_digits</code>, which is in charge of translating the raw characters to a <a href="#list">List</a> of integral <a href="#number">Numbers</a>. The radix and digits are then forwarded to <code>compute</code>, which adds up the digits according to the radix.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... tokens&gt;</div><div class="line"><span class="keyword">struct </span>make_number :</div><div class="line">    compute&lt;metal::number&lt;long long, 10&gt;, parse_digits_t&lt;tokens...&gt;&gt;</div><div class="line">{};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... tokens&gt;</div><div class="line"><span class="keyword">struct </span>make_number&lt;<a class="code" href="namespacemetal.html">metal</a>::<a class="code" href="group__number.html#gabbc51719da6b0cfb01a5d8617ebee59e">character</a>&lt;&#39;0&#39;&gt;, tokens...&gt; :</div><div class="line">    compute&lt;metal::number&lt;long long, 8&gt;, parse_digits_t&lt;tokens...&gt;&gt;</div><div class="line">{};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... tokens&gt;</div><div class="line"><span class="keyword">struct </span>make_number&lt;metal::<a class="code" href="group__number.html#gabbc51719da6b0cfb01a5d8617ebee59e">character</a>&lt;&#39;0&#39;&gt;, <a class="code" href="group__number.html#gabbc51719da6b0cfb01a5d8617ebee59e">metal::character</a>&lt;&#39;x&#39;&gt;, tokens...&gt; :</div><div class="line">    compute&lt;metal::number&lt;long long, 16&gt;, parse_digits_t&lt;tokens...&gt;&gt;</div><div class="line">{};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... tokens&gt;</div><div class="line"><span class="keyword">struct </span>make_number&lt;metal::<a class="code" href="group__number.html#gabbc51719da6b0cfb01a5d8617ebee59e">character</a>&lt;&#39;0&#39;&gt;, <a class="code" href="group__number.html#gabbc51719da6b0cfb01a5d8617ebee59e">metal::character</a>&lt;&#39;X&#39;&gt;, tokens...&gt; :</div><div class="line">    compute&lt;metal::number&lt;long long, 16&gt;, parse_digits_t&lt;tokens...&gt;&gt;</div><div class="line">{};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... tokens&gt;</div><div class="line"><span class="keyword">struct </span>make_number&lt;metal::<a class="code" href="group__number.html#gabbc51719da6b0cfb01a5d8617ebee59e">character</a>&lt;&#39;0&#39;&gt;, <a class="code" href="group__number.html#gabbc51719da6b0cfb01a5d8617ebee59e">metal::character</a>&lt;&#39;b&#39;&gt;, tokens...&gt; :</div><div class="line">    compute&lt;metal::number&lt;long long, 2&gt;, parse_digits_t&lt;tokens...&gt;&gt;</div><div class="line">{};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... tokens&gt;</div><div class="line"><span class="keyword">struct </span>make_number&lt;metal::<a class="code" href="group__number.html#gabbc51719da6b0cfb01a5d8617ebee59e">character</a>&lt;&#39;0&#39;&gt;, <a class="code" href="group__number.html#gabbc51719da6b0cfb01a5d8617ebee59e">metal::character</a>&lt;&#39;B&#39;&gt;, tokens...&gt; :</div><div class="line">    compute&lt;metal::number&lt;long long, 2&gt;, parse_digits_t&lt;tokens...&gt;&gt;</div><div class="line">{};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... tokens&gt;</div><div class="line"><span class="keyword">using</span> make_number_t = <span class="keyword">typename</span> make_number&lt;tokens...&gt;::type;</div></div><!-- fragment --><p> Notice that we followed the notation used by Metal and defined <code>make_number_t</code> as an alias to <code>typename make_number&lt;&gt;::type</code> to save typing.</p>
<h3>Parsing the Digits</h3>
<p>To parse the characters into the corresponding integral, we need first to remove all digit separators. That can be easily accomplished using <code><a class="el" href="group__list.html#ga93b95511c576dbe0f7da4c15e778e148">metal::remove</a></code>, which takes a <a href="#list">List</a> <code>l</code> and a <a href="#value">Value</a> <code>v</code> and returns another <a href="#list">List</a> that contains every element from <code>l</code> and in the same order, except for those that are identical to <code>v</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> tokens = <a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list</a>&lt;</div><div class="line">    <a class="code" href="group__number.html#gabbc51719da6b0cfb01a5d8617ebee59e">metal::character&lt;'3'&gt;</a>,</div><div class="line">    <a class="code" href="group__number.html#gabbc51719da6b0cfb01a5d8617ebee59e">metal::character&lt;'\''&gt;</a>,</div><div class="line">    <a class="code" href="group__number.html#gabbc51719da6b0cfb01a5d8617ebee59e">metal::character&lt;'7'&gt;</a>,</div><div class="line">    metal::character&lt;&#39;\&#39;&#39;&gt;,</div><div class="line">    <a class="code" href="group__number.html#gabbc51719da6b0cfb01a5d8617ebee59e">metal::character&lt;'1'&gt;</a></div><div class="line">&gt;;</div><div class="line"></div><div class="line">static_assert(std::is_same&lt;</div><div class="line">    <a class="code" href="group__list.html#ga219c3ea0ca741a51e5a248bc42cda149">metal::remove_t</a>&lt;tokens, metal::character&lt;&#39;\&#39;&#39;&gt;&gt;,</div><div class="line">    <a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list</a>&lt;</div><div class="line">        metal::character&lt;&#39;3&#39;&gt;,</div><div class="line">        metal::character&lt;&#39;7&#39;&gt;,</div><div class="line">        metal::character&lt;&#39;1&#39;&gt;</div><div class="line">    &gt;</div><div class="line">&gt;::value, <span class="stringliteral">&quot;&quot;</span>);</div></div><!-- fragment --><p> The remaining digits can then be transformed into the corresponding <a href="#number">Numbers</a> using <code><a class="el" href="group__list.html#gacefd3f0ae8424824c147c3971d811ad5">metal::transform</a></code>, which takes a <a href="#lambda">Lambda</a> <code>lbd</code> and a <a href="#list">List</a> <code>l</code> and returns another <a href="#list">List</a> containing the results of <em>invoking</em> <code>lbd</code> for each element in <code>l</code>. </p><pre class="fragment">[lbd(l[0]), lbd(l[1]), ..., lbd(l[n-2]), lbd(l[n-1])]
</pre><p>First we need an <a href="#expression">Expression</a> that maps characters to <a href="#number">Numbers</a> from which we can construct our <code>lbd</code>. We'll call it <code>to_number</code> and it is rather trivial.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> c&gt;</div><div class="line"><span class="keyword">struct </span>to_number :</div><div class="line">    <a class="code" href="group__optional.html#ga39cd1f0c733205cc6fd1cdbb7ad64d0b">metal::cond</a>&lt;</div><div class="line">        metal::equal_to&lt;c, metal::character&lt;&#39;0&#39;&gt;&gt;, metal::number&lt;long long, 0&gt;,</div><div class="line">        metal::equal_to&lt;c, metal::character&lt;&#39;1&#39;&gt;&gt;, metal::number&lt;long long, 1&gt;,</div><div class="line">        metal::equal_to&lt;c, metal::character&lt;&#39;2&#39;&gt;&gt;, metal::number&lt;long long, 2&gt;,</div><div class="line">        metal::equal_to&lt;c, metal::character&lt;&#39;3&#39;&gt;&gt;, metal::number&lt;long long, 3&gt;,</div><div class="line">        metal::equal_to&lt;c, metal::character&lt;&#39;4&#39;&gt;&gt;, metal::number&lt;long long, 4&gt;,</div><div class="line">        metal::equal_to&lt;c, metal::character&lt;&#39;5&#39;&gt;&gt;, metal::number&lt;long long, 5&gt;,</div><div class="line">        metal::equal_to&lt;c, metal::character&lt;&#39;6&#39;&gt;&gt;, metal::number&lt;long long, 6&gt;,</div><div class="line">        metal::equal_to&lt;c, metal::character&lt;&#39;7&#39;&gt;&gt;, metal::number&lt;long long, 7&gt;,</div><div class="line">        metal::equal_to&lt;c, metal::character&lt;&#39;8&#39;&gt;&gt;, metal::number&lt;long long, 8&gt;,</div><div class="line">        metal::equal_to&lt;c, metal::character&lt;&#39;9&#39;&gt;&gt;, metal::number&lt;long long, 9&gt;,</div><div class="line">        metal::equal_to&lt;c, metal::character&lt;&#39;a&#39;&gt;&gt;, metal::number&lt;long long, 10&gt;,</div><div class="line">        metal::equal_to&lt;c, metal::character&lt;&#39;b&#39;&gt;&gt;, metal::number&lt;long long, 11&gt;,</div><div class="line">        metal::equal_to&lt;c, metal::character&lt;&#39;c&#39;&gt;&gt;, metal::number&lt;long long, 12&gt;,</div><div class="line">        metal::equal_to&lt;c, metal::character&lt;&#39;d&#39;&gt;&gt;, metal::number&lt;long long, 13&gt;,</div><div class="line">        metal::equal_to&lt;c, metal::character&lt;&#39;e&#39;&gt;&gt;, metal::number&lt;long long, 14&gt;,</div><div class="line">        metal::equal_to&lt;c, metal::character&lt;&#39;f&#39;&gt;&gt;, metal::number&lt;long long, 15&gt;,</div><div class="line">        metal::equal_to&lt;c, metal::character&lt;&#39;A&#39;&gt;&gt;, metal::number&lt;long long, 10&gt;,</div><div class="line">        metal::equal_to&lt;c, metal::character&lt;&#39;B&#39;&gt;&gt;, metal::number&lt;long long, 11&gt;,</div><div class="line">        metal::equal_to&lt;c, metal::character&lt;&#39;C&#39;&gt;&gt;, metal::number&lt;long long, 12&gt;,</div><div class="line">        metal::equal_to&lt;c, metal::character&lt;&#39;D&#39;&gt;&gt;, metal::number&lt;long long, 13&gt;,</div><div class="line">        metal::equal_to&lt;c, metal::character&lt;&#39;E&#39;&gt;&gt;, metal::number&lt;long long, 14&gt;,</div><div class="line">        metal::equal_to&lt;c, metal::character&lt;&#39;F&#39;&gt;&gt;, metal::number&lt;long long, 15&gt;</div><div class="line">    &gt;</div><div class="line">{};</div></div><!-- fragment --><p> Now we can transform characters to <a href="#number">Numbers</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> digits = <a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list</a>&lt;</div><div class="line">    metal::character&lt;&#39;3&#39;&gt;,</div><div class="line">    metal::character&lt;&#39;7&#39;&gt;,</div><div class="line">    metal::character&lt;&#39;1&#39;&gt;</div><div class="line">&gt;;</div><div class="line"></div><div class="line">static_assert(std::is_same&lt;</div><div class="line">    <a class="code" href="group__list.html#ga61ea84621d6c85e098c5e182604b58cb">metal::transform_t</a>&lt;to_number&lt;metal::_1&gt;, digits&gt;,</div><div class="line">    <a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list</a>&lt;</div><div class="line">        <a class="code" href="group__number.html#ga1e4f1eb3349be74f99e7c70e4af8be9e">metal::number&lt;long long, 3&gt;</a>,</div><div class="line">        <a class="code" href="group__number.html#ga1e4f1eb3349be74f99e7c70e4af8be9e">metal::number&lt;long long, 7&gt;</a>,</div><div class="line">        <a class="code" href="group__number.html#ga1e4f1eb3349be74f99e7c70e4af8be9e">metal::number&lt;long long, 1&gt;</a></div><div class="line">    &gt;</div><div class="line">&gt;::value, <span class="stringliteral">&quot;&quot;</span>);</div></div><!-- fragment --><p> That peculiar <code><a class="el" href="group__placeholders.html#ga2158e3dd5180b12b04dc1dc487fef023">metal::_1</a></code> is a <a class="el" href="group__placeholders.html">Placeholder</a> and it works like this: when <code>to_number&lt;<a class="el" href="group__placeholders.html#ga2158e3dd5180b12b04dc1dc487fef023">metal::_1</a>&gt;</code> is invoked with some argument, <code><a class="el" href="group__placeholders.html#ga2158e3dd5180b12b04dc1dc487fef023">metal::_1</a></code> will be substituted for that argument and only then <code>to_number</code> is <em>evaluated</em>.</p>
<p>Putting it all together we have</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... tokens&gt;</div><div class="line"><span class="keyword">struct </span>parse_digits :</div><div class="line">    <a class="code" href="group__list.html#gacefd3f0ae8424824c147c3971d811ad5">metal::transform</a>&lt;</div><div class="line">        to_number&lt;metal::_1&gt;,</div><div class="line">        metal::remove_t&lt;metal::list&lt;tokens...&gt;, metal::character&lt;&#39;\&#39;&#39;&gt;&gt;</div><div class="line">    &gt;</div><div class="line">{};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... tokens&gt;</div><div class="line"><span class="keyword">using</span> parse_digits_t = <span class="keyword">typename</span> parse_digits&lt;tokens...&gt;::type;</div></div><!-- fragment --> <h3>Computing the Number</h3>
<p>Now we turn our attention to <code>compute</code>. It takes the radix and a list of <a href="#number">Numbers</a> representing the digits and is in charge of adding up the digits according to the radix, that is </p><pre class="fragment">D0*radix^(n-1) + D1*radix^(n-2) + ... + D{n-2}*radix + D{n-1}
</pre><p>The first thing we notice is that the <em>ith</em> digit actually corresponds to the <em>(n-1-i)th</em> power of the radix, so, to make things simpler, we need to <code><a class="el" href="group__list.html#gac69bde34e621837dd89023c99d0254e5">metal::reverse</a></code> the order of digits.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> digits = <a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list</a>&lt;</div><div class="line">    <a class="code" href="group__number.html#ga1e4f1eb3349be74f99e7c70e4af8be9e">metal::number&lt;long long, 3&gt;</a>,</div><div class="line">    <a class="code" href="group__number.html#ga1e4f1eb3349be74f99e7c70e4af8be9e">metal::number&lt;long long, 7&gt;</a>,</div><div class="line">    <a class="code" href="group__number.html#ga1e4f1eb3349be74f99e7c70e4af8be9e">metal::number&lt;long long, 1&gt;</a></div><div class="line">&gt;;</div><div class="line"></div><div class="line">static_assert(std::is_same&lt;</div><div class="line">    <a class="code" href="group__list.html#ga3085d94ff17d359ea102b6c1a80164f7">metal::reverse_t&lt;digits&gt;</a>,</div><div class="line">    <a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list</a>&lt;</div><div class="line">        metal::number&lt;long long, 1&gt;,</div><div class="line">        metal::number&lt;long long, 7&gt;,</div><div class="line">        metal::number&lt;long long, 3&gt;</div><div class="line">    &gt;</div><div class="line">&gt;::value, <span class="stringliteral">&quot;&quot;</span>);</div></div><!-- fragment --><p> Then we have </p><pre class="fragment">D0 + D1*radix + ... + D{n-2}*radix^(n-2) + D{n-1}*radix^(n-1)
</pre><p>Now we need to <code><a class="el" href="group__number.html#gaaea8abdb5a6906c8402c450981de2dc5">metal::enumerate</a></code> the exponents that correspond to each digit.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> digits = <a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list</a>&lt;</div><div class="line">    metal::number&lt;long long, 1&gt;,</div><div class="line">    metal::number&lt;long long, 7&gt;,</div><div class="line">    metal::number&lt;long long, 3&gt;</div><div class="line">&gt;;</div><div class="line"></div><div class="line">static_assert(std::is_same&lt;</div><div class="line">    <a class="code" href="group__number.html#gad4f6df40a8af4c76c825b1af088d0b1b">metal::enumerate_t</a>&lt;<a class="code" href="group__number.html#ga1e4f1eb3349be74f99e7c70e4af8be9e">metal::number&lt;long long, 0&gt;</a>, <a class="code" href="group__list.html#ga0a14517a9f48b5b338ac3834fd44bced">metal::size_t&lt;digits&gt;</a>&gt;,</div><div class="line">    <a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list</a>&lt;</div><div class="line">        <a class="code" href="group__number.html#ga1e4f1eb3349be74f99e7c70e4af8be9e">metal::number&lt;long long, 0&gt;</a>,</div><div class="line">        metal::number&lt;long long, 1&gt;,</div><div class="line">        <a class="code" href="group__number.html#ga1e4f1eb3349be74f99e7c70e4af8be9e">metal::number&lt;long long, 2&gt;</a></div><div class="line">    &gt;</div><div class="line">&gt;::value, <span class="stringliteral">&quot;&quot;</span>);</div></div><!-- fragment --><p> This version of <code><a class="el" href="group__number.html#gaaea8abdb5a6906c8402c450981de2dc5">metal::enumerate</a></code> takes two <a href="#number">Numbers</a>, <code>start</code> and <code>size</code>, and returns a <a href="#list">List</a> containing a sequence of <a href="#number">Numbers</a> beginning with <code>start</code> and ending in <code>size - 1</code>. </p><pre class="fragment">[start, start + 1, ..., size - 2, size - 1]
</pre><div class="panel panel-warning"><div class="panel-heading"><span class="octicon octicon-info"></span>Note</div><div class="panel-body"> All <a href="#number">Numbers</a> in the sequence have the same type as <code>start</code> regardless of the type of <code>size</code>. </div></div><p>The next step is to compute each term of the sum. We'll be using <code><a class="el" href="group__list.html#gacefd3f0ae8424824c147c3971d811ad5">metal::transform</a></code> again, but this time it takes a <em>binary</em> <a href="#lambda">Lambda</a> <code>lbd</code> and two <a href="#list">Lists</a> <code>l1</code> and <code>l2</code> and returns a new <a href="#list">List</a> formed by <em>invoking</em> <code>lbd</code> for the elements of <code>l1</code> and <code>l2</code> pairwise. </p><pre class="fragment">[lbd(l1[0], l2[0]), lbd(l1[1], l2[1]), ..., lbd(l1[n-2], l2[n-2]), lbd(l1[n-1], l2[n-1])]
</pre><div class="fragment"><div class="line"><span class="keyword">using</span> radix = <a class="code" href="group__number.html#ga1e4f1eb3349be74f99e7c70e4af8be9e">metal::number&lt;long long, 10&gt;</a>;</div><div class="line"><span class="keyword">using</span> digits = <a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list</a>&lt;</div><div class="line">    metal::number&lt;long long, 1&gt;,</div><div class="line">    metal::number&lt;long long, 7&gt;,</div><div class="line">    metal::number&lt;long long, 3&gt;</div><div class="line">&gt;;</div><div class="line"><span class="keyword">using</span> exponents = <a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list</a>&lt;</div><div class="line">    <a class="code" href="group__number.html#ga1e4f1eb3349be74f99e7c70e4af8be9e">metal::number&lt;long long, 0&gt;</a>,</div><div class="line">    metal::number&lt;long long, 1&gt;,</div><div class="line">    <a class="code" href="group__number.html#ga1e4f1eb3349be74f99e7c70e4af8be9e">metal::number&lt;long long, 2&gt;</a></div><div class="line">&gt;;</div><div class="line"></div><div class="line">static_assert(std::is_same&lt;</div><div class="line">    <a class="code" href="group__list.html#ga61ea84621d6c85e098c5e182604b58cb">metal::transform_t</a>&lt;</div><div class="line">        <a class="code" href="group__arithmetic.html#ga5e3b3da2093629acf3c88cdcbdc25fcd">metal::mul</a>&lt;metal::_1, <a class="code" href="group__arithmetic.html#ga7f55966963c8cc2564a81c7523550350">metal::pow&lt;radix, metal::_2&gt;</a>&gt;,</div><div class="line">        digits,</div><div class="line">        exponents</div><div class="line">    &gt;,</div><div class="line">    <a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list</a>&lt;</div><div class="line">        metal::number&lt;long long, 1&gt;,</div><div class="line">        <a class="code" href="group__number.html#ga1e4f1eb3349be74f99e7c70e4af8be9e">metal::number&lt;long long, 70&gt;</a>,</div><div class="line">        <a class="code" href="group__number.html#ga1e4f1eb3349be74f99e7c70e4af8be9e">metal::number&lt;long long, 300&gt;</a></div><div class="line">    &gt;</div><div class="line">&gt;::value, <span class="stringliteral">&quot;&quot;</span>);</div></div><!-- fragment --><p> Here again <code><a class="el" href="group__placeholders.html#ga2158e3dd5180b12b04dc1dc487fef023">metal::_1</a></code> and <code><a class="el" href="group__placeholders.html#ga91c75729b0f78f2b5c069aec6cb07ef4">metal::_2</a></code> are <a class="el" href="group__placeholders.html">Placeholders</a> that get substituted for the first and second arguments with which <code>lbd</code> is invoked, prior to the recursive <em>evaluation</em> of the <a href="#expression">Expressions</a> that form the <a href="#lambda">Lambda</a>.</p>
<p>Finally we need to sum up the terms, so basically we need to invoke <code><a class="el" href="group__arithmetic.html#ga9b2e18aa329355bfd7da7b374823b421">metal::add</a></code> for the elements contained in a <a href="#list">List</a>. That's exactly what <code><a class="el" href="group__list.html#ga507751878f61207f883c49f265c1913d">metal::apply</a></code> is for.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> terms = <a class="code" href="group__list.html#ga45230fa3bb5136fc2c47bb68e962ee94">metal::list</a>&lt;</div><div class="line">    metal::number&lt;long long, 1&gt;,</div><div class="line">    <a class="code" href="group__number.html#ga1e4f1eb3349be74f99e7c70e4af8be9e">metal::number&lt;long long, 70&gt;</a>,</div><div class="line">    <a class="code" href="group__number.html#ga1e4f1eb3349be74f99e7c70e4af8be9e">metal::number&lt;long long, 300&gt;</a></div><div class="line">&gt;;</div><div class="line"></div><div class="line">static_assert(std::is_same&lt;</div><div class="line">    <a class="code" href="group__list.html#gae4fffbe5ca63206e55e829d965040130">metal::apply_t</a>&lt;<a class="code" href="group__lambda.html#gad1c1dcdd5fae23712d016b52504cbb22">metal::lambda&lt;metal::add&gt;</a>, terms&gt;,</div><div class="line">    <a class="code" href="group__number.html#ga1e4f1eb3349be74f99e7c70e4af8be9e">metal::number&lt;long long, 371&gt;</a></div><div class="line">&gt;::value, <span class="stringliteral">&quot;&quot;</span>);</div></div><!-- fragment --><p> Here we used <code><a class="el" href="group__lambda.html#gad1c1dcdd5fae23712d016b52504cbb22">metal::lambda</a>&lt;<a class="el" href="group__arithmetic.html#ga9b2e18aa329355bfd7da7b374823b421">metal::add</a>&gt;</code> which is basically a synonym for </p><pre class="fragment">metal::add&lt;metal::_1, metal::_2, ..., metal::arg&lt;n-2&gt;, metal::arg&lt;n-1&gt;&gt;
</pre><p>where <code>n</code> is the number of arguments with which <code><a class="el" href="group__lambda.html#gad1c1dcdd5fae23712d016b52504cbb22">metal::lambda</a>&lt;<a class="el" href="group__arithmetic.html#ga9b2e18aa329355bfd7da7b374823b421">metal::add</a>&gt;</code> is invoked, that is the size of the <a href="#list">List</a> in this particular case. This way we don't need to care about the actual number of arguments.</p>
<p>We now have all the pieces needed to define <code>compute</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> radix, <span class="keyword">typename</span> digits&gt;</div><div class="line"><span class="keyword">struct </span>compute :</div><div class="line">    <a class="code" href="group__list.html#ga507751878f61207f883c49f265c1913d">metal::apply</a>&lt;</div><div class="line">        metal::lambda&lt;metal::add&gt;,</div><div class="line">        metal::transform_t&lt;</div><div class="line">            metal::mul&lt;metal::_1, metal::pow&lt;radix, metal::_2&gt;&gt;,</div><div class="line">            metal::reverse_t&lt;digits&gt;,</div><div class="line">            metal::enumerate_t&lt;</div><div class="line">                metal::number&lt;long long, 0&gt;,</div><div class="line">                metal::size_t&lt;digits&gt;</div><div class="line">            &gt;</div><div class="line">        &gt;</div><div class="line">    &gt;</div><div class="line">{};</div></div><!-- fragment --><p> And we are done.</p>
<div class="fragment"><div class="line">static_assert(std::is_same&lt;</div><div class="line">    decltype(01234567_c), <span class="comment">//octal</span></div><div class="line">    <a class="code" href="group__number.html#ga1e4f1eb3349be74f99e7c70e4af8be9e">metal::number&lt;long long, 342391&gt;</a></div><div class="line">&gt;::value, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line">static_assert(std::is_same&lt;</div><div class="line">    decltype(123456789_c), <span class="comment">//decimal</span></div><div class="line">    <a class="code" href="group__number.html#ga1e4f1eb3349be74f99e7c70e4af8be9e">metal::number&lt;long long, 123456789&gt;</a></div><div class="line">&gt;::value, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line">static_assert(std::is_same&lt;</div><div class="line">    decltype(0xABCDEF_c), <span class="comment">//hexadecimal</span></div><div class="line">    <a class="code" href="group__number.html#ga1e4f1eb3349be74f99e7c70e4af8be9e">metal::number&lt;long long, 11259375&gt;</a></div><div class="line">&gt;::value, <span class="stringliteral">&quot;&quot;</span>);</div></div><!-- fragment --><p> It also works for very long binary literals.</p>
<div class="fragment"><div class="line">static_assert(std::is_same&lt;</div><div class="line">    decltype(0b111101101011011101011010101100101011110001000111000111000111000_c),</div><div class="line">    <a class="code" href="group__number.html#ga1e4f1eb3349be74f99e7c70e4af8be9e">metal::number&lt;long long, 8888888888888888888&gt;</a></div><div class="line">&gt;::value, <span class="stringliteral">&quot;&quot;</span>);</div></div><!-- fragment --><p> And ignores digit separators too.</p>
<div class="fragment"><div class="line">static_assert(std::is_same&lt;</div><div class="line">    decltype(1<span class="charliteral">&#39;2&#39;</span>3<span class="charliteral">&#39;4&#39;</span>5<span class="charliteral">&#39;6&#39;</span>7<span class="charliteral">&#39;8&#39;</span>9_c),</div><div class="line">    <a class="code" href="group__number.html#ga1e4f1eb3349be74f99e7c70e4af8be9e">metal::number&lt;long long, 123456789&gt;</a></div><div class="line">&gt;::value, <span class="stringliteral">&quot;&quot;</span>);</div></div><!-- fragment --></div></div><!-- contents -->
        </div>
      </div>
    </div>
    <div id="footer">
      <div class="container">
        <div class="row text-muted">
          <div class="col-md-12">
            <ul class="social-btns">
              <li class="social-btn">
                <iframe class="github-btn" src="https://ghbtns.com/github-btn.html?user=brunocodutra&amp;repo=metal&amp;type=watch&amp;count=true" title="Star on GitHub" height="20" width="100"></iframe>
              </li>
              <li class="social-btn">
                <iframe class="github-btn" src="https://ghbtns.com/github-btn.html?user=brunocodutra&amp;repo=metal&amp;type=fork&amp;count=true" title="Fork on GitHub" height="20" width="102"></iframe>
              </li>
            </ul>
            &copy; Copyright 2015
            <a href="https://github.com/brunocodutra">Bruno Dutra</a>,
            <span class="hidden-xs">Distributed under the</span>
            <a href="http://www.boost.org/LICENSE_1_0.txt">
              Boost Software License, Version 1.0
            </a>
          </div>
        </div>
      </div>
    </div>
    <script type="text/javascript" src="jquery-1.11.3.min.js"></script>
    <script type="text/javascript" src="bootstrap.min.js"></script>
    <script type="text/javascript" src="metal.js"></script>
  </body>
</html>
